================================================================================
EEG数据存储与处理方案 (本地参考文档，不提交到Git)
================================================================================
制定日期: 2025-10-30
基于: DATA_ANALYSIS.txt 的分析结果

================================================================================
一、数据存储策略（最终方案）
================================================================================

【选择方案】实时切分 + 内存缓存

原因:
1. 灵活性高 - 可以动态处理removeEOG和extractMI参数
2. 存储效率 - 不需要预先生成大量切分文件
3. 性能可控 - 通过缓存机制保证响应速度
4. 易于维护 - 数据源集中管理

================================================================================
二、目录结构（推荐）
================================================================================

EEG_back/
├── app/
│   └── data/
│       ├── source/                        # 数据源（符号链接）
│       │   ├── processed/                 # 链接到原始processed_data
│       │   │   ├── A01T_continuous_epochs.npz -> /Users/.../EEG_local/processed_data/...
│       │   │   └── ... (A02-A09)
│       │   └── cleaned/                   # 链接到processed_data_cleaned
│       │       ├── A01T_continuous_epochs_cleaned.npz -> /Users/.../EEG_local/...
│       │       └── ... (A02-A09)
│       └── cache/                         # 运行时缓存（不提交Git）
│           └── trials/                    # trial数据缓存（.npy格式）
└── DATA_ANALYSIS.txt                      # 数据分析文档（不提交）
└── DATA_STORAGE_PLAN.txt                  # 本文档（不提交）

说明:
- 使用符号链接避免复制大文件
- cache/目录用于运行时缓存，提升性能
- 所有txt和cache都在.gitignore中

================================================================================
三、数据加载流程
================================================================================

【流程图】

前端请求
   ↓
GET /api/trials/{trialId}/eeg-data?removeEOG=true&extractMI=false
   ↓
DataLoader.load_trial_data()
   ↓
检查内存缓存? ── Yes → 直接返回
   ↓ No
检查文件缓存? ── Yes → 加载缓存 → 存入内存 → 返回
   ↓ No
根据参数选择数据源:
   - removeEOG=false, extractMI=false: 不支持（没有原始文件）
   - removeEOG=true, extractMI=false: 使用 processed/
   - removeEOG=true, extractMI=true: 使用 cleaned/
   ↓
加载完整npz文件到内存
   ↓
解析event标记，切分出指定trial
   ↓
提取5个通道 (C3, Cz, C4, CP1, CP2)
   ↓
转换为前端格式
   ↓
存入内存缓存 + 文件缓存（可选）
   ↓
返回JSON响应

================================================================================
四、关键数据结构
================================================================================

1. 通道索引映射（固定）:
   C3  -> index 7
   Cz  -> index 9
   C4  -> index 11
   CP1 -> index 15
   CP2 -> index 17

2. Event类型映射:
   '769' -> label 0 -> 'left'
   '770' -> label 1 -> 'right'
   '771' -> label 2 -> 'foot'
   '772' -> label 3 -> 'tongue'

3. Trial命名规则:
   格式: {Subject}{Session}{Index:03d}
   示例: A01T001, A01T002, ..., A09T288

4. 前端响应格式:
   {
     "success": true,
     "data": {
       "original": {
         "channels": {
           "C3": [1000个float],
           "Cz": [1000个float],
           "C4": [1000个float],
           "CP1": [1000个float],
           "CP2": [1000个float]
         },
         "labels": [0, 0.004, 0.008, ..., 3.996],
         "samplingRate": 250,
         "trialInfo": {
           "id": "A01T001",
           "subject": 1,
           "trialIndex": 1,
           "motionType": "left",
           "label": 0
         }
       },
       "processed": { /* 同样格式，根据removeEOG/extractMI参数 */ }
     }
   }

================================================================================
五、缓存策略
================================================================================

【三级缓存】

Level 1: 内存缓存（优先级最高）
- 使用Python字典存储
- 缓存键: f"{subject}_{data_type}"
- 存储完整的npz数据
- 限制: 每个文件<100MB才缓存（避免内存溢出）
- 生命周期: 应用运行期间

Level 2: NPZ文件缓存（中等优先级）
- 缓存已加载的完整npz数据
- 位置: 内存中的_cache字典
- 避免重复IO读取

Level 3: 文件缓存（可选，暂不实现）
- 位置: app/data/cache/trials/
- 格式: {trial_id}_{data_type}.npy
- 用于加速频繁访问的trials

【缓存更新策略】
- 应用启动时清空Level 1
- Level 2在内存中持久化
- Level 3文件缓存可设置过期时间（如24小时）

================================================================================
六、removeEOG和extractMI参数的处理逻辑
================================================================================

前端参数组合 -> 后端数据源选择:

| removeEOG | extractMI | 数据源                     | 说明                       |
|-----------|-----------|----------------------------|----------------------------|
| false     | false     | ❌ 不支持                  | 没有完全原始的数据         |
| true      | false     | processed/                 | 去除EOG，保留完整时序      |
| true      | true      | cleaned/                   | 去除EOG + 提取MI段         |
| false     | true      | ❌ 逻辑错误                | 不可能MI但不去EOG          |

实际实现:
- 只提供两种模式: processed 和 cleaned
- 前端的original显示 = processed数据
- 前端的processed显示 = 根据extractMI选择processed或cleaned

简化版本（推荐）:
- removeEOG参数忽略（因为都已经去除了EOG）
- 只用extractMI参数控制:
  * extractMI=false -> 使用processed/
  * extractMI=true -> 使用cleaned/

================================================================================
七、API接口设计
================================================================================

1. GET /api/trials
   功能: 获取所有trials列表
   参数:
     - subject (optional): 1-9
     - motionType (optional): "left" | "right" | "foot" | "tongue"

   返回:
   {
     "success": true,
     "data": [
       {
         "id": "A01T001",
         "subject": 1,
         "trialIndex": 1,
         "motionType": "left",
         "label": 0
       },
       ...
     ],
     "total": 288
   }

2. GET /api/trials/{trialId}/eeg-data
   功能: 获取特定trial的EEG数据
   参数:
     - trialId: path参数，如 "A01T001"
     - removeEOG: query参数，默认true（实际忽略）
     - extractMI: query参数，默认false

   返回: (见第四节数据结构)

================================================================================
八、数据加载服务实现要点
================================================================================

class DataLoader:

    1. 初始化:
       - 加载数据源路径配置
       - 初始化内存缓存字典
       - 预生成trials元数据列表

    2. load_subject_data(subject, data_type):
       - 检查缓存
       - 加载完整npz文件
       - 解析events
       - 缓存数据

    3. load_trial_data(trial_id, extract_mi):
       - 解析trial_id -> subject + trial_index
       - 选择数据源（processed/cleaned）
       - 加载subject数据
       - 定位trial在MI events中的索引
       - 切分数据
       - 提取5通道
       - 转换格式
       - 返回

    4. get_all_trials(subject, motion_type):
       - 从预生成的元数据中筛选
       - 支持分页（可选）

================================================================================
九、性能优化建议
================================================================================

1. 首次加载优化:
   - 预加载A01的数据（最常用）
   - 异步加载其他subjects

2. 内存管理:
   - LRU缓存策略（最近最少使用）
   - 设置最大缓存数量（如最多缓存3个subjects）

3. 响应速度优化:
   - 使用numpy的高效切片操作
   - 避免不必要的数据复制
   - 考虑使用memmap加载大文件

4. 并发处理:
   - 使用FastAPI的异步特性
   - 数据加载用线程池
   - 避免阻塞主线程

================================================================================
十、实施步骤
================================================================================

【第一步】创建数据源链接
1. 创建 app/data/source/processed 目录
2. 创建 app/data/source/cleaned 目录
3. 为9个npz文件创建符号链接

【第二步】实现DataLoader服务
1. 创建 app/services/data_loader.py
2. 实现基础加载功能
3. 实现trial切分逻辑
4. 实现缓存机制

【第三步】创建数据模型
1. app/models/trial.py - Trial模型
2. app/models/eeg.py - EEGData模型

【第四步】实现API接口
1. app/api/trials.py - GET /api/trials
2. app/api/eeg_data.py - GET /api/trials/{id}/eeg-data

【第五步】测试验证
1. 单元测试 - 测试数据加载
2. 集成测试 - 测试API接口
3. 性能测试 - 测试响应时间

【第六步】前后端联调
1. 启动后端服务
2. 修改前端API调用
3. 验证数据格式
4. 测试所有功能

================================================================================
十一、预期性能指标
================================================================================

- 首次加载subject数据: <2秒
- 缓存命中后加载trial: <50ms
- Trial列表查询: <100ms
- 内存占用: <500MB（缓存3个subjects）
- 并发支持: 10+ 同时请求

================================================================================
十二、注意事项
================================================================================

1. ⚠️ 数据文件路径硬编码问题:
   - 当前使用绝对路径: /Users/yangminyue/coding_coding/EEG_local/
   - 建议: 使用符号链接或配置文件
   - 部署时需要更新路径配置

2. ⚠️ 数据版本管理:
   - 如果原始数据更新，需要清空缓存
   - 建议添加数据版本号检测

3. ⚠️ 错误处理:
   - 文件不存在
   - 数据格式异常
   - 内存不足
   - Trial ID不存在

4. ⚠️ 安全性:
   - 验证trial_id格式
   - 防止路径遍历攻击
   - 限制请求频率

================================================================================
结束
================================================================================